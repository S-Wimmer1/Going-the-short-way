'''
die Ausgabekoordinaten sollten sinnvollerweise immer Bezugs des Antriebskoordinatensystems sein. Man kann aber auch wieder ins Horizontsystem rückrechnen, das passiert ja effektiv zwischen dem Server-Plugin der Antriebssteuerung und dem Client genau so.

Benchmarken muss man dass in dem Sinn ja auch nicht zwangsläufig. Es ergibt sich ja schon aus dem Hamilton'schen Prinzip rein argumentativ, dass der kürzeste Weg der zeitlich günstigste sein muss, solang die Elevationsachse mindestens die halbe Winkelgeschwindigkeit der Azimutachse hat.

Die Überrotation ist die Strategie, die man möglichst vermeiden sollte. In der Antriebssteuerung gibt es diese Option, die autonom eine Überrotation ausführt, wenn die Azimutdistanz für die kommandierten Zielkoordinaten kürzer ist als der "nominale" Azimutbereich von 0-360.

Man kann daher davon ausgehen, dass sich das Teleskop immer in diesem Bereich bewegen soll, weil das die bevorzugte Konfiguration ist. Daher ist die Selektion der flip-over-Option die einzig gesuchte Bedingung.

Den gefragten Algorithmus hab ich ja schon als Kommentar angegeben, unten nochmal der Vollständigkeit halber. Die Zielkoordinatenpaare im Antriebssystem waren jeweils dort angegeben wo "goto" im listing stand. Ich hab es nochmal abgeändert, die _g sind jetzt die Ausgabekoordinaten für die Steuerung.

Als Funktion in python-Syntax würde man das folgendermaßen darstellen:
'''

az_g, el_g = determine_drive_coordinates(az_t, el_t)

command_drive(az_g, el_g)

'''Die _t kommen als Kommando vom Client an den Server, die _g gehen an die Steuerung. Die Rückmeldung des aktuellen Teleskop-Pointings an den Client bleibt unverändert, diese Koordinaten werden wie bisher aus den Koordinaten des Antriebs (_d) bestimmt.
'''



#LIM ... upper EL drive limit

#_d ... current drive coordinates
#_t ... target coordinates
#_r ... reverse-path coordinates
#_g ... drive command coordinates


az_r = az_t - 180
el_r = 180 - el_t

if el_r > LIM then
    az_g = az
    el_g = el
else

    delta   = | |az_d - az|   - |el_d - el|   |
    delta_r = | |az_d - az_r| - |el_d - el_r| |

    if delta_r <= delta then
        az_g = az_r
        el_g = el_r
    else
        az_g = az
        el_g = el
    endif
endif

goto az_g, el_g





##########
Der Vollständigkeit halber hier die Lösung der Projektaufgabe. Eine Berechnung der Großkreisdistanz zwischen den Punkten ist dafür gar nicht nötig, da die beiden Rotationsachsen eine fixe, rechtwinkelige Beziehung zueinander haben. Damit reduziert sich die Problemstellung auf eine simple, eindimensionale links-rechts Entscheidung. Der Check für das EL Limit ist eigentlich nur dann nötig, wenn die mechanische EL-Achse nicht symmetrisch eingestellt ist (was bei uns der Fall ist).

Ich hab das vorhin implementiert und getestet, es macht genau was es soll. Ein weiterer Check zur Überdrehung in AZ ist ebenfalls gar nicht nötig, weil der flip-over tendenziell immer dazu führt, dass die Antriebskoordinaten immer bevorzugt im 0-360 Bereich landen. Da EL immer schneller dreht als AZ ist auch die Gewichtung implizit unnötig, weil EL bei der Auswahl durch die maximal halbe Bogenlänge bevorzugt wird.



LIM ... upper EL drive limit

_d ... current drive coordinates
_t ... target coordinates
_r ... reverse-path coordinates


az_r = az_t - 180
el_r = 180 - el_t

if el_r > LIM then
goto az, el
else

delta = | |az_d - az| - |el_d - el| |
delta_r = | |az_d - az_r| - |el_d - el_r| |

if delta_r <= delta then
goto az_r, el_r
else
goto az, el
endif
endif
